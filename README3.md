# Общие сведения #
Репозиторий представляет собой независимый composer-модуль, предназначенный для фильтрации входящих http-запросов для блокирования спам-трафика и общей защиты по определённым сигнатурам.
<br>
<br>

# Установка и подключение файлов #
`Шаг 1.` Клонирование git-репозитория

Так как файерволл устанавливается как локальный composer-пакет (через symlink), то рекомендуется размещать git-репозиторий файерволла вне DOCUMENT_ROOT вашего сайта (как в данной инструкции):
```bash
wafdir=/home/bitrix/shared/packages/webformat.waf-ii && \
mkdir -p $wafdir && cd $wafdir && \
git clone https://Web-format@github.com/Web-format/waf-ii.git .
```
`Шаг 2.` Далее нужно скопировать главный конфиг и поправить его (при необходимости):
```bash
cp config.default.ini config.ini
```

`Шаг 3.` При отсутствии в установленного в системе `composer` нужно его установить:

Установку composer делаем по инструкции со страницы https://getcomposer.org/download/

Также она подробнее записана в нашей базе https://docs.google.com/document/d/1TUrTvgQ7GYIlF1Gznmv4wdTGMsZq7oWvYFPKj7jvVXs/edit в папке "База знаний ВФ" -> "Нераспределенное"

<br>

`Шаг 4.` Прописать репозиторий файерволла в `composer.json` вашего сайта

Добавьте строки в ваш корневой для проекта `composer.json`-файл:

В секцию `repositories` (создать при необходимости), а также `require`:
```json
"repositories": {
    "webformat.waf-ii": {
        "type": "path",
        "url": "/home/bitrix/shared/packages/webformat.waf-ii",
        "options": {
            "symlink": true
        }
    }
},
"require": {
    "webformat/waf-ii": "@dev"
}
```

Если файл вообще отсутствует, то можно заполнить его так:
```json
{
   "name": "webformat/project.name",
   "repositories": {
       "webformat.waf-ii": {
           "type": "path",
           "url": "/home/bitrix/shared/packages/webformat.waf-ii",
           "options": {
               "symlink": true
           }
       }
   },
   "authors": [
       {
           "name": "webformat",
           "email": "test@webformat.ru"
       }
   ],
   "require": {
       "webformat/waf-ii": "@dev"
   }
}
```

`Шаг 5.` Подготовка папки для лог-файлов
```bash
# от рута в системе, где работает php (хост-система или docker-контейнер)
logdir=/var/log/waf-ii && \
mkdir -p $logdir && chown root:bitrix $logdir && chmod -v 730 $logdir && \
touch "$logdir/summary.log" "$logdir/post.extended.log" "$logdir/debug.log" && \
find $logdir -type f -exec chown root:bitrix {} \; \
-exec chmod -v 620 {} \;
```


`Шаг 6.` Собственно установка composer-пакета

В командной строке из `document-root` вашего сайта выполнить (из php-контейнера или хост-системы, где установлен php и composer):
```bash
composer update webformat/waf-ii
```
Важно! Если при выполнении этой команды вы сталкиваетесь с ошибкой:
```bash
Composer could not find a composer.json file in ...
```
...то это значит, что у вас в принципе не было установлено ещё ни одного пакета из composer.json и отсутствует файл composer.lock. В таком случае просто выполните полную установку composer.json:
```bash
composer update
```

<br>
<br>

# Собственно подключение файерволла к коду сайта #
<u>Для включения</u> работы межсетевого экрана нужно сделать следующее:

<br>
<br>

**`Вариант 1 (рекомендуется):`** (через auto_pepend_file)

<u>Для конфигурации PHP как модуль Apache:</u>

В файле виртуального хоста вашего httpd нужно добавить новый путь для php-параметра `include_path`:
```apache
<Directory /home/bitrix/ext_www/site.ru>
    Options FollowSymLinks MultiViews
    AllowOverride All
    ...
    # Через двоеточие дописываем кастомную папку
    php_admin_value include_path ".:/usr/share/pear:/usr/share/php:/home/bitrix/shared/packages"
</Directory>
```

...после чего сделать reload httpd:
```bash
httpd -t && systemctl reload httpd
```

Далее относительно этого пути нужно в `.htaccess` вашего сайта прописать путь к запуску межсетевого экрана. В стандартный пакет входит файл по умолчанию, подходящий для большинства случаев. Подключить его можно так:
```apache
# в вашем .htaccess или в том же файле вирт. хоста:
php_value auto_prepend_file "webformat.waf-ii/bin/check.php"
```

<br>
<br>

<u>Для конфигурации PHP-FPM:</u>

В файл конфига пула (обычно `/etc/php-fpm.d/www.conf`) прописать путь в `include_path`:
```ini
# Через двоеточие дописываем кастомную папку
php_value[include_path]=".:/usr/share/pear:/usr/share/php:/home/bitrix/shared/packages"
```

Далее в `document-root` вашего сайта создайте файл `.user.ini` (если его не было):
```bash
# укажите корректный путь к document root вашего сайта
iniPath=/home/bitrix/ext_www/site.ru/.user.ini && \
echo 'auto_prepend_file="webformat.waf-ii/bin/check.php"' >> $iniPath && \
chown root:bitrix $iniPath && chmod 640 $iniPath && chattr +i $iniPath
```

Наполните его следующим содержимым:
```ini
auto_prepend_file="webformat.waf-ii/bin/check.php"
```

Важно создавать его с защитой от редактирования и удаления со стороны непривилигированных пользователей (как в примере), т.к. в противном случае они смогут отключить файерволл (например, при заражении сайта вирусом).

После того, как создали файл .user.ini и наполнили его нужным содержимым, нужно сделать релоад php-fpm:
```bash
systemctl reload php-fpm
```

<br>
<br>

**`Вариант 2:`** (через include)

В `dbconn.php` или в любом другом максимально рано запускаемом на хите php-файле пропишите:
```php
// При необходимости содержимое этого файла можно скопировать и произвольным образом кастомизировать
include '/home/bitrix/shared/packages/webformat.waf-ii/bin/check.php';
```
<br>
<br>

# Базовое конфигурирование `config.ini` #
Данный файл содержит как общие настройки файерволла, так и параметры по умолчанию, которые будут унаследованы пользовательскими профилями проверки запросов (пункт о профилях см. далее).

Рассмотрим отдельно каждую секцию этого файла:

<br>
<br>

1. `[apply_if]` (опциональная секция)

В данной секции описываются условия по умолчанию, при наступлении которых файерволл должен сработать. Каждый пользовательский профиль наследует значения из этой секции и может их для себя переопределить (если нужно расширить или сузить условия срабатывания отдельно взятого профиля).

Из коробки задано следующее условие: запускать проверки только для POST-запросов, причём если режим работы PHP не является консольным. В данном случае исходим из того, что излишне запускать файерволл для cron-заданий и для всех GET-запросов.

Чтобы отключить в своём профиле то или иное требование, нужно переопределить его. Например, если в config.ini задано следующее условие:

```ini
# в config.ini:
[apply_if]
target="_SERVER[REQUEST_METHOD]"
target_match='/^POST/i'

# в вашем профиле.ini:
[apply_if]
target="_SERVER[REQUEST_METHOD]"
target_match='/.*/i'
```
В этом примере ваш профиль будет применяться для любого типа запроса (не только POST).

Также данную секцию уместно использовать для задания каких-то общих исключений в работе файерволла: например, чтобы отключить его для некоторых IP. Тогда достаточно добавить в этот блок соответствующее правило:
```ini
# в config.ini:
[apply_if]
#...
target3="_SERVER[REMOTE_ADDR]"
target3_match_not='/123\.123\.123\.123/'
# или (то же самое, но с отрицанием внутри рег. выражения)
# target3_match="/^(?!123\.123\.123\.123)/"
```

<br>
<br>

2. `[general]` - секция для общих настроек

Все параметры из данной секции могут быть переопределены в одноимённой секции пользовательского профиля. Более того, параметры `reaction`, `analyse` могут быть переопределены на уровне каждой отдельной секции `allow_*` или `block_*` пользовательского профиля (и их действие будет распространяться именно на эту секцию).

<table>
    <thead>
        <tr>
            <th>Параметр</th>
            <th>Общее описание</th>
            <th>Доп. комментарии</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <i style="color:yellow">passive_mode</i><br>
            </td>
            <td>Указывает, должен ли межсетевой экран блокировать запросы</td>
            <td>1 = только писать лог;<br>0 = писать лог + блокировать</td>
        </tr>
        <tr>
            <td>
                <i style="color:yellow">reaction</i><br>
            </td>
            <td>Описывает, что должен сделать модуль в качестве блокировочной реакции</td>
            <td>
                <b style="color:orange">null</b> = будут произведены следующие изменения:
                    <code style="display:block;background:black;color:white; margin: 15px 0;">
                    $_REQUEST = $_POST = [];<br>
                    $_SERVER['REQUEST_METHOD'] = 'GET';
                </code>
                <b style="color:orange">403</b> = будет возвращён статус 403 Forbidden (выполнение страницы тут же будет остановлено)<br>
                <b style="color:orange">404</b> = будет возвращён статус 404 Not Found (выполнение страницы тут же будет остановлено)
            </td>
        </tr>
        <tr>
            <td>
                <i style="color:yellow">analyse</i><br>
            </td>
            <td>Указывает, нужно ли проверять значения переменных запроса в "чистом" виде - или же производить предобработку и проверять уже обработанные значения (можно указывать несколько вариантов проверки через запятую - если будет совпадение при проверке хотя бы одного из них, файерволл вернёт блокировку)</td>
            <td>
                <b style="color:orange">raw</b> = проверять только нетронутые значения;<br>
                <b style="color:orange">base64_decoded</b> = проверять только base64-декодированные значения;<br>
                <b style="color:orange">base64_decoded_recursive</b> = проверять только base64-декодированные значения, причём рекурсивно (т.е. продолжать декодировать уже декодированные, пока в нём есть похожие на base64-подпоследовательности);<br>
                <b style="color:orange">url_decoded</b> = проверять только url-декодированные значения;<br>
                <b style="color:orange">url_decoded_recursive</b> = проверять только url-декодированные значения, причём рекурсивно (т.е. продолжать декодировать, пока это меняет значение);<br>
                <br>
                Пример (проверяем "сырые" значения + рекурсивно base64- и url-декодированные):
                <code style="display:block;background:black;color:white; margin: 8px 0;">
                analyse='raw,base64_decoded_recursive,url_decoded_recursive'
                </code>
                <br>
                => Важно, что комбинация параметров <b>"url_decoded*"</b> и <b>"base64_decoded*"</b> позволяет этим функциям работать совместно (выполняем url-декодирование, потом декодируем base64-подпоследовательности, потом снова url-декодирование и т.д.);
            </td>
        </tr>
        <tr>
            <td>
                <i style="color:yellow">base64_min_chunk_length</i><br>
            </td>
            <td>Минимальная длина похожей на base64-закодированной последовательности</td>
            <td>Настройка имеет смысл, только если в контексте секции в параметре "analyse" встречается значение "base64_decoded" или "base64_decoded_recursive". Тогда строки, короче указанного значения, не будут декодироваться (для экономии ресурсов).</td>
        </tr>
        <tr>
            <td>
                <i style="color:yellow">logdir</i><br>
            </td>
            <td>Папка для логов (по умолчанию). Будет создана автоматически, если не существует</td>
            <td>Относительно неё можно указывать другие пути, особенно в секциях вида "[write_log => ...]"</td>
        </tr>
        <tr>
            <td>
                <i style="color:yellow">logmask</i><br>
            </td>
            <td>Маска для создаваемых лог-файлов (если они отсутствуют).</td>
            <td>По умолчанию выбрано такое значение, чтобы права на лог-файлы были 220 - только права на запись для владельца и группы. Права на чтение лучше не давать, т.к. лог-файлы могут содержать конфиденциальную информацию аутентификации администраторов сайта.</td>
        </tr>
    </tbody>
</table>

<br>
<br>

3. `[log_formats]` - секция для объявления форматов записываемой в лог-файлы информации
Ключами этой секции являются названия форматов, а значениями - строки, содержащие переменные, значения которых попадут в лог. Доступные переменные:

- date - дата в формате "YYYY-MM-DD";
- datetime - дата со временем в формате "YYYY-MM-DDTHH:MM:SS";
- request = var_export($_REQUEST);
- server = var_export($_SERVER);
- serverName = значение SERVER_NAME;
- journal = var_export от журнала проверки запроса;
- uri = REQUEST_URI;
- method = метод запроса (POST, GET и т.д.);
- ip = IP-адрес;
- matchedValue = последнее проверенное значение, соответствующее профилю (привело к блокировке);
- valueRoute = путь проверенного значения (_REQUEST[foo][bar]);
- profile = названия файла последнего применённого профиля;
- section = название последней применённой ini-секции;
- target = target, target2 и т.д. из последней проверенной секции (на которой произошла блокировка);
- regex = последнее применённое рег. выражение;
- regexId = ID рег. выражения (по комментарию в нём, если он задан);
- userAgent = HTTP_USER_AGENT;
- referer = HTTP_REFERER;
- checkTime = время, ушедшее на проверку запроса файерволлом.

Также в значениях форматов поддерживаются служебные последовательности `[br]` и `\n`, означающие перенос строки.

Форматы, объявленные в секции `log_formats`, используются в секциях `[write_log => ...]`.

<br>
<br>

4. `[log_filter_*]` - набор секций, объявляющих фильтры для логов

Объявление подобных фильтров позволяет записывать в логи информацию только по тем запросам, которые соответствуют условиям из этих фильтров. Данные фильтры используются в секциях `[write_log => ...]`.

Условия задаются в обычном `target-match` синтаксисе по аналогии с блоками `allow_*` и `block_*`.

<br>
<br>

5. `[write_log => ...]` - набор секций, описывающих ведение лог-файлов

В этих секциях указывается, какую информацию и при каких условиях нужно записывать в какой конкретно файл.

Декларативный синтаксис этих секций позволяет указать сочетание следующих параметров:
<table>
    <thead>
        <tr>
            <th>Параметр</th>
            <th>Общее описание</th>
            <th>Доп. комментарии</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <i style="color:yellow">Тип события</i> для записи лога<br>
            </td>
            <td>Указывает, в какой момент собрать информацию для лог-файла</td>
            <td>В текущей версии поддерживается три события:<br>
                <b style="color:orange">received</b> - запрос получен, но ещё не обработан ни одним профилем (то есть мы ещё не знаем, нужно его разрешить или заблокировать). По сути, это любой запрос, дошедший до уровня PHP и места подключения файерволла.<br>
                <b style="color:orange">black</b> - запрос проанализирован файерволлом и должен быть заблокирован (уже есть информация о том, какому профилю, секции и рег. выражению он соответствует);<br>
                <b style="color:orange">white</b> - запрос проанализирован файерволлом, и не предпринято блокирующих действий
            </td>
        </tr>
        <tr>
            <td>
                <i style="color:yellow">Формат</i> для записи лога<br>
            </td>
            <td>Какой-либо ключ из секции <i style="color:yellow">[log_formats]</i></td>
            <td>Указывает, какую именно информацию мы хотим записать в лог-файл</td>
        </tr>
        <tr>
            <td>
                <i style="color:yellow">Фильтр</i> для записи лога<br>
            </td>
            <td>Название какой-либо из секций <i style="color:yellow">[log_filter_*]</i></td>
            <td>Определяет, каким условиям должен соответствовать запрос, чтобы информацию о нём мы записали в указанный лог-файл</td>
        </tr>
    </tbody>
</table>

Способ сочетания этих параметров удобнее всего продемострировать на конкретных примерах (от простых к более сложным):
```ini
# В этом примере мы хотим логировать общую информацию о любом запросе
# Для этого мы объявили формат "general_info" в секции "log_formats"
# ...и увязали его с событием "received" - в названии секции "write_log".
# Также мы указали, что собираемся записывать эту информацию в два разных файла (одну и ту же)
[log_formats]
#...
general_info = '$ip $datetime $method "$uri" <-- "$referer"; "$userAgent"'

[write_log => received:general_info]
0 = "#logdir#/access.log"
1 = "/home/bitrix/access.log"
```

```ini
# В этом примере мы хотим логировать общую информацию о любом запросе в файл "#logdir#/access.log",
# Расширенную информацию о любом POST-запросе - в дргой;
# а расширенную информацию о заблокированных post-запросах - в третий
# Для этого мы объявили два интересующих нас формата логов в секции "log_formats";
# Также объявили лог-фильтр "onlypost", в котором определяется соответствие запроса методу POST.
# А затем описали все эти условия в секциях
# [write_log => received] и [write_log => black.onlypost]

[log_formats]
#...
short = '$ip $datetime $method "$uri" <-- "$referer"; "$userAgent"'
full = "$ip $datetime $method $uri[br]_REQUEST:[br]$request[br]_SERVER:[br]$server[br]journal:[br]$journal[br2]"

[log_filter_onlypost]
target="_SERVER[REQUEST_METHOD]"
match='/POST/i'

[write_log => received]
short[] = "#logdir#/access.log"
full.onlypost[] = "#logdir#/access.post.log"

[write_log => black.onlypost]
0 = "#logdir#/blocked.post.log"
```

```ini
# В следующем примере мы хотим логировать информацию о разрешённых и заблокированных запросах
# в единый файл, причём если запрос был заблокирован, то в строке лог-файле
# мы хотим увидеть доп. информацию о причинах блокировки

[log_formats]
general = '$ip $datetime $method "$uri" <-- "$referer"; "$userAgent"'
black_summary = " => blocked by $profile[$section][$target]: $regexId\n"

[write_log => received:general,black:black_summary]
0 ="#logdir#/summary.log"
```
Немного поясним последний пример. В части "received:general,black:black_summary" указано следующее: если поступил некий запрос, записать информацию о нём по формату "general" (и остановиться на этом, если по итогу запрос был разрешён). Если же в итоге запрос оказался заблокированным, то дописать информацию о блокировке по формату "black_summary". Запись в указанный лог-файл произойдёт единой строкой (и за одну операцию, а не две - фактически, происходит конкатенация строк двух различных форматов).

<br>
<br>

# Конфигурирование движка перед запуском #

В момент непосредственного вызова кода движка файерволла можно задать ряд важных параметров:

- отредактировать перечень папок, в которых будут искаться профили;
- отредактировать перечень профилей, которые должны быть исполнены (в указанных папках);
- задать контент страниц, если движок должен его модифицировать;

Для определения папок профилей могут быть использованы следующие методы (на объекте движка): `onlyDir`, `withDir` (каждый из них принимает аргументом массив путей к папкам).

Первый метод указывает точный список папок, в которых будут искаться профили (и только в них). Второй добавляет указанные папки к перечную по умолчанию (на текущий момент это только подпапка `profiles` в расположении данного репозитория).

По аналогии можно управлять списком запускаемых профилей через методы: `only`, `with`, `without`. Каждый из них принимает аргументом список названий файлов профилей (при указании допустимо опускать расширение ".ini").

Чтобы задать движку контент страницы для потенциальной обработки (если это предполагается профилями), нужно передать его как строку в метод `setPageContent`.

Возможный пример:

```php
(new \Webformat\Waf\Engine([]))
    ->onlyDir([$_SERVER['DOCUMENT_ROOT'].'/local/dom-profiles'])
    ->setPageContent($content)
    ->check();
```

В данном случае мы ограничили движку перечень рассматриваемых папок только путём `$_SERVER['DOCUMENT_ROOT'].'/local/dom-profiles` (то есть профили будут искаться только в этой папке).
И задали контент страницы, который будет модифицироваться в соответствии с заданиями из профилей, указанных в этой папке.


<br>
<br>

# Пользовательские профили #
В подпапке `profiles` относительно корня модуля хранятся профили с правилами обработки запросов.
В метод `check()` основного движка файерволла передаётся массив с названиями как раз этих профилей (но без постфикса ".ini"). Если массив с профилями в этот метод не передавать (или передавать пустой) - будут исполнены все имеющиеся в папке профили в соответствии с их условиями, описанными в ini-секциях `[apply_if]`.

Если запрос подходит под условия блокировки хотя бы одного из обрабатываемых профилей, он будет заблокирован.

Если же запрос подпадает под исключения одного из профилей (т.е. должен быть разрешён в контексте профиля), то это исключение рассматривается только в контексте профиля. Это значит, что если по одному профилю запрос должен быть разрешён, а по другому - запрещён, то в итоге он будет запрещён.

<br>
<br>

## Структура обычного профиля ##
Внутри папки ./profiles (от корня модуля) можно создать любое количество своих профилей. Каждый профиль представляет собой обычный секционный ini-файл. Секции исполняются сверху вниз. Верхние вспомогательные опциональные секции - `[apply_if]` и `[general]`. Переменные внутри них дублируют те же, что и в одноимённых секциях из конфигурационного файла `config.ini` и переопределяют их в контексте профиля.


Все последующие секции должны иметь обязательный префикс в своём названии:
- `allow` - запрос будет разрешён, если соответствует правилам, описанным в профиле;
- `block` - запрос будет заблокирован, если соответствует правилам, описанным в профиле. Тип блокировки будет определён в соответствии с параметром `reaction` (либо в секции `general`, либо если в ней не задан, то в основном `config.ini` файле);
- `remove` - секция применяется к контенту страницы и позволяет задать `xpath`-селекторы. Все узлы html-страницы, соответствующие этим селекторам, будут с неё удалены;
- `delegate` - секция применяется к контенту страницы и позволяет задать `xpath`-селекторы в паре с перечнем `callback`-функций. Каждый элемент `DOM`-структуры, соответствующий указанным селекторам, будет передан в каждый перечисленный `callback`;


Исполнение профилей при наступлении любого из событий:
- Достигнут конец профиля;
- Найдена `allow`- или `block`-секция, правилам которой соответствует текущий http-запрос.

Далее разберём переменные внутри `allow`- или `block`-секций:

<table>
    <tbody>
        <tr>
            <th>Переменная</th>
            <th>Описание</th>
            <th>Примеры</th>
        </tr>
        <tr>
            <td>
                <i style="color:yellow">reaction</i><br>
            </td>
            <td>Параметр, аналогичный такому же из блока [general], но действующий только в контексте ini-секции (в одной секции может быть указано возвращать 403 ошибку, в другой - 404)</td>
            <td></td>
        </tr>
        <tr>
            <td><i style="color:yellow">target</i><br><i style="color:yellow">target2</i><br><i style="color:yellow">target3</i> и т.д.</td>
            <td>
                Описание серверной переменной, значения которой будут проверяться на соответствие тем или иным правилам.
                Если какой-либо ключ представляет собой регулярное выражение, перед "target" надо ставить точку с запятой: ":target=".<br>
                <u>Заметка о regex</u>: простые паттерны ключей могут быть указаны без обрамляющих символов "/", "#" и др., например: .* (в этом случае они будут автоматически трансформированы в паттерн /^.*$/). Также поддерживается полный синтаксис: /^foo/i<br>
                <b>Важно:</b> паттерны ".*" и "*" отличаются в плане применения рекурсивного обхода. В первом случае паттерн воспринимается как обычное регулярное выражение - под него подпадут все ключи данной переменной (без рекурсивного обхода). Паттерн "*" - специальное значение, подразумевающее полный обход рассматриваемой переменной: _REQUEST[*] означает любое значение на любом уровне вложенности.<br><br>
                В одном блоке может быть несколько target, тогда все, начиная со второго, должны иметь постфикс в виде числа: target2, target3 и т.д.
            </td>
            <td>
                <ul>
                    <li>target='_SERVER[REMOTE_ADDR]'</li>
                    <li>:target='_REQUEST[/^form.*/]'</li>
                    <li>:target='_REQUEST[.*]'</li>
                    <li>:target='_REQUEST[*]'</li>
                    <li>:target='_REQUEST[foo][bar][.*]'</li>
                </ul>
            </td>
        </tr>
        <tr>
            <td><i style="color:yellow">target_not</i><br><i style="color:yellow">target2_not</i><br><i style="color:yellow">target3_not</i> и т.д.</td>
            <td>
                Позволяют исключить ту или иную переменную запроса из проверки. Удобнее всего продемонстрировать на примере (см. ячейку справа)
            </td>
            <td>
                <u>Пример:</u><br>
                <code lang="ini">
                    [block_1]<br>
                    :target='_REQUEST[*]'<br>
                    target_not[]='_REQUEST[MESSAGE]'<br>
                    target_not[]='_REQUEST[ACTION][\d+][ARGUMENTS][data][DESCRIPTION]'<br>
                    target_not[]='_REQUEST[REVIEW_TEXT]'<br>
                    target_not[]='_REQUEST[data][COMMENT_TEXT]'<br>
                    match[]='/\.\.\//i'
                </code>
                <br>
                В этом примере проверяется, содержит ли какая-то переменная запроса подстроку `../`. В то же время, данная подстрока разрешена в некоторых переменных запроса - они исключаются из проверки
            </td>
        </tr>
        <tr>
            <td><i style="color:yellow">logic</i></td>
            <td>
                "or" = запрос соответствует правилам блока, если соответствует правилам хотя бы одного его target' (является значением по умолчанию - можно не указывать)<br>
                "and" = запрос соответствует правилам блока, если соответствует правилам всех его target'ов<br>
            </td>
            <td>
                <u>Пример 1:</u><br>
                <code lang="ini">
                    [allow_1]<br>
                    logic=and<br>
                    target='_SERVER[REMOTE_ADDR]'<br>
                    (...какие-то правила для IP...)<br>
                    target2='_SERVER[HTTP_USER_AGENT]'<br>
                    (...какие-то правила для проверки User Agent...)<br>
                </code>
                => означает, что запрос соответствует правилам (и будет разрешён в контексте профиля), если и IP-адрес, и User Agent соответствуют перечисленным настройкам<br><br>
                <u>Пример 2:</u><br>
                <code lang="ini">
                    [block_me]<br>
                    target='_SERVER[REMOTE_ADDR]'<br>
                    (...какие-то правила для IP...)<br>
                    target2='_SERVER[HTTP_USER_AGENT]'<br>
                    (...какие-то правила для проверки User Agent...)<br>
                </code>
                => означает, что запрос соответствует правилам (и будет заблокирован), если либо IP-адрес, либо User Agent соответствуют перечисленным настройкам
            </td>
        </tr>
        <tr>
            <td>
                <i style="color:yellow">match[]</i>,<br>
                <i style="color:yellow">match_target<span style="color:red">N</span>[]</i>,<br>
                <i style="color:yellow">match_not[]</i>,<br>
                <i style="color:yellow">target<span style="color:red">N</span>_match_not[]</i>,<br>
                <i style="color:yellow">-match[]</i>,<br>
                <i style="color:yellow">-match_target<span style="color:red">N</span>[]</i>
            </td>
            <td>
                Одно или несколько регулярных выражений для проверки соответствующего target.<br>
                Если match начинается с символа "-" (-match) или заканчивается на "_not", это значит, что запрос соответствует блоку, если НЕ соответствует рег. выражению.
            </td>
            <td>
                <code lang="ini">
                    [block_123]<br>
                    logic=or<br>
                    :target='_REQUEST[form_text_(22|33)]'<br>
                    ; Имя длиннее 30 символов - спам<br>
                    match[]='/^[\w\s]{30,}/u'<br>
                    ; Имя длиннее 3 слов (от 4 и более) - спам<br>
                    match[]='/(\S+\s){4,}/uU'<br><br>
                    target2='_SERVER[REMOTE_ADDR]'<br>
                    ; лочим IP, которые начинаются на 100 или НЕ начинаются на 10 (101 будет разрешено, а 100 или 200 - нет)
                    match_target2[]='/^100/'<br>
                    -match_target2[]='/^10/'<br>
                </code>
            </td>
        </tr>
        <tr>
            <td>
                <i style="color:yellow">match[logic]</i>,<br>
                <i style="color:yellow">match_target<span style="color:red">N</span>[logic]</i><br>
            </td>
            <td>
                "or" (по умолчанию - можно не указывать): будет считаться, что запрос соответствует target'у, если соответствует хотя бы одному match из группы<br>
                "and": будет считаться, что запрос соответствует target'у, только если соответствует всем рег. выражениям из соотв. группы match<br>
            </td>
            <td>
                Заблокируем запросы, в которых встречается строка "iframe", но не встречается "IFRAME_TYPE":<br>
                <code lang="ini">
                    target9='_SERVER[REQUEST_URI]'<br>
                    match_target9[logic]=and<br>
                    match_target9[]='/iframe/i'<br>
                    -match_target9[]='/IFRAME_TYPE/i'<br>
                </code>
            </td>
        </tr>
    </tbody>
</table>

<br>
<br>

Рассмотрим структуру `remove`-профиля:
```ini
[remove dom elements]
; метрики (яндекс и гугл)
0 = '//script[contains(@src,"googletagmanager") or contains(@src,"mc.yandex.ru")]'
1 = '//script[contains(@src,"popup.js")]'
2 = '//div[@id="headerfixed" or @class="share hover-block top" or child::header[@id="header"]]'
```

Ключи в этой секции могут быть произвольные (но уникальные). А значения - `xpath`-селекторы.

<br>
<br>

Рассмотрим структуру `delegate`-профиля:
```ini
[delegate nodes to webformat.cdn]
select[] = '//img[@src] | //script[@src] | //link[@href] | //*[contains(@style,"url") or contains(@data-obgi,"url")] | //div[@data-big] | //a[@data-thumb]'
; select[] = '//img[@src]'
callback[] = "Webformat\\Cdn\\Support\\Facades\\UrlReplacer::processNode"
```
В ключе `select` можно указать произвольное количество `xpath`-селекторов (будет взята совокупность). Каждый элемент DOM-структуры, подпадающий под селектор, будет передан в указанные в параметре `callback` функции обратного вызова.

Это позволяет использовать более тонкую модификацию DOM-контента.

<br>
<br>

# Специальное значение `":null:"` и пустые строки #
Бывает, что нужно заблокировать/разрешить какой-то запрос, если та или иная переменная в нём отсутсвует полностью или передана, но является пустой.
Для этих случаев предусмотрен следующий синтаксис:
```ini
[block_empty_request_1]
; эта блокировка сработает, если в запросе нет ключа empty_var
target='_REQUEST[empty_var]'
match[]=':null:'

; эта блокировка сработает, если в запросе есть ключ empty_var со скалярным значением (в т.ч. пустая строка)
target2='_REQUEST[empty_var]'
target2_match[]='/.*/'

; эта блокировка сработает, если в запросе есть ключ empty_var с любым значением (в т.ч. массив)
target3='_REQUEST[empty_var][*]'
target3_match[]='/.*/'
```

Можно также использовать синтаксис с отрицанием:
```ini
[block_filled_request]
; эта блокировка сработает, если в запросе присутствует ключ should_be_empty со скалярным значением
target='_REQUEST[should_be_empty]'
match_not[]=':null:'

; эта блокировка сработает, если в запросе присутствует ключ should_be_empty с любым значением (в т.ч. массив)
target2='_REQUEST[should_be_empty][*]'
target2_match_not[]=':null:'

; в текущей версии эта блокировка никогда не сработает в связи с невыполнимостью своего условия: ключ should_be_empty существует и имеет любое значение (с null данный синтаксис не сравнивает)
target3='_REQUEST[should_be_empty]'
target3_match_not[]='/.*/'

; в текущей версии эта блокировка тоже никогда не сработает
target4='_REQUEST[should_be_empty][*]'
target4_match_not[]='/.*/'
```

**Разница между сравнением с пустым рег. выражением и `:null:`**
<br>
```ini
[block_empty_referer]
target='_SERVER[HTTP_REFERER]'
; сработает для случая, когда заголовок Referer вообще не передан
match[]=':null:'
; сработает для случая, когда заголовок Referer передан, но является пустой строкой
match[]='/^$/'
```

<b style="color:red;">Важно!</b> Значения `:null:` можно комментировать наподобие рег. выражений:
```ini
[block_section]
target='_REQUEST[WEB_FORM_ID]'
match[]='(?#signatureId):null:'
```

<br>
<br>

# Примеры типичных ситуаций #
1. Добавить URL к исключениям из блокировок (в контексте профиля). Для этого в начале профиля (или сразу после секции `[general]`, если она заведена) создаём секцию, название которой должно начинаться на `allow`:
```ini
[allow_1]
target='_SERVER[REQUEST_URI]'
match[]='/^\/bitrix\/admin\//'
```
Если мы хотим, чтобы это исключение распространялось на все профили, нам следует внести его в файл general.ini (содержимое этого файла будет рассматриваться как начало всех профилей).


2. Запретить во всех переменных запроса подстроку "<?php", но разрешить её в $_REQUEST[form_data][filesrc] и _REQUEST[filesrc]:

```ini
[block_php_tag]
:target='_REQUEST[*]'
target_not[] = '_REQUEST[form_data][filesrc]'
target_not[] = '_REQUEST[filesrc]'
match[]='/(\<\?php)/i'

:target2='_REQUEST[foo.*]'
target2_not[] = '_REQUEST[foobar]'
target2_match[]='/val/i'
```

3. Пример антиспам-профиля:

см. в файле ./profiles/.antispam.ini.example
```bash
# После копирования профиля произведите его проверку, расширение конкретными для проекта правилами, а также 
# замените идентификаторы полей веб-форм на актуальные (в рег. выражениях)
.antispam.ini.example antispam.ini
```


<br><br>

# Настройки для logrotate #

```bash
# создаём файл профиля
touch /etc/logrotate.d/waf2

# наполняем его содержимым:
/var/log/waf-ii/*.log {
    su root root
    daily
    missingok
    create 620 root bitrix
    rotate 30
    compress
    delaycompress
    notifempty
    sharedscripts
}

# проверяем синтаксис
/usr/sbin/logrotate -d /etc/logrotate.d/waf2

```

<br><br>

# Настройки проверки логов для модуля самодиагностики #

(заполняются в настройках битрикс-модуля [Самодиагностика](https://bitbucket.org/wfrepo/git.webformat.selfdiag/src/master/))

**1. Папка**: /home/bitrix/shared/log/nginx

Шаблон пути файлов: \*access\*.log

`*like*`-шаблоны:

- \\/bitrix\\/admin\\/.*reason: (?!0)\\d
- '\\/upload\\/.*reason: (?!0)\\d
- utm_.*reason: (?!0)\\d

<br>
<br>

**2. Папка**: /home/bitrix/shared/log/waf2

Шаблон пути файлов: summary.log

`*like*`-шаблоны:

- \\/bitrix\\/admin\\/.*blocked
- ajax\\.php.*blocked
- utm_.*blocked

<br>
<br>

**3. Пример cron-задания**:
```bash
#selfdiag
*/30 * * * *    flock -xn /home/bitrix/shared/tmp/selfdiag.lock        php /home/bitrix/shared/cli/gate.php -d"/home/bitrix/ext_www/site.ru" -s"site.ru" bitrix/modules/webformat.selfdiag/exec/check.php &> /home/bitrix/shared/log/selfdiag.log
```

<br>
<br>

# Калибровка #
Изначально нужно включить пассивный режим:
```ini
; config.ini:
passive_mode=1
```
... и собирать статистику в логах, время от времени анализируя их на предмет ложноположительных срабатываний.

Порядок проверки логов:

<br>

1. Подготавливаем набор файлов `summary.log`'ов и `post.extended.log`'ов, по которым будет производиться поиск. Для этого можно воспользоваться скриптом unpack_logs.sh из [репозитория cli-gate](https://bitbucket.org/wfrepo/cli-gate/src/master/utils/unpack_logs.sh). Например:
```bash
# чтобы ограничить набор файлов, используйте параметр "--wildcard"
# чтобы указать папку, отличную от "/var/log/nginx", используйте параметр "--from"
# чтобы запустить скрипт в холостом режиме (только отображение списка файлов), используйте параметр "--list-only"
# если калибруем в I раз - записываем интересующую нас дату, с которой начинаем отбор:
echo "`date -I -d '10 days ago'`T00:00:00" > /root/last-waf-ii-check.log

wafLastCheck=`cat /root/last-waf-ii-check.log` && \
mkdir -p /root/logs/`date -I`-waf2 && \
cd /root/logs/`date -I`-waf2 && \
bash /home/bitrix/shared/cli/utils/unpack_logs.sh --from="/var/log/waf-ii" --to="/root/logs/`date -I`-waf2" --wildcard="*.log*"  --since="$wafLastCheck"
```

<br>

2. Составляем частотную таблицу кодов блокировок (кодов сигнатур, по которым были блокировки) 

Для этого уместно вначале убрать из выборки устаревшие по дате запросы или выполненные ботами. Если у нас есть список их IP-адресов (например, по результатам калибровки I ступени), то отбрасываем их, чтобы не тратить время:
```bash
cat summary* | awk -v from="`cat /root/last-waf-ii-check.log`" '$2 >= from' | grep -iP '\sblocked\s' | grep -viP '(...список IP...)' > list.log
```

Затем по оставшимся запросам строим таблицу:
```bash
cat list.log | awk '{print $NF}' | tr '|' '\n' | grep . | sort | uniq -c | sort -nr
```
Получаем результат примерно следующего вида (`частота` => `код блокировки`):
```ini
77   10
29   7
9    18
5    52
```

<br>

3. Вручную обрабатываем каждую строку таблицы из предыдущего пункта. Берём число из правого столбца (код блокировки) и просматриваем запросы с помощью вспомогательного скрипта.
Для удобства создаём симв. ссылку на этот php-скрипт:
```bash
ln -s /home/bitrix/shared/packages/webformat.waf-ii/bin/calibrate/filter.php filter.php
```

Далее для каждого кода блокировки:
```bash
cat post.extended.log* | ./filter.php --since="2023-09-27T20:19:28" --max-portions=1 --sig-id=10
# добавляем исключения по мере просмотра
cat post.extended.log* | ./filter.php --since="2023-09-27T20:19:28" --max-portions=1 --sig-id=10 --exclude='fbclid|SCRIPT_URL.*autosave'
```

Если найденный запрос "белый" и его надо исключить - думаем, как это правильнее сделать:
- написать исключение в рег. выражение, по которому осуществлена блокировка
- добавить IP-адрес, с которого поступил запрос, в белый список
- добавить запрос в секцию `[allow_...]` в конец основного `config.ini`

<br>

4. Добавляем в исключения IP-адреса доверенных источников:

В секцию `apply_if` файла `config.ini` добавляем следующее по счёту правило:
```ini
target3="_SERVER[REMOTE_ADDR]"
target3_match_logic="and"
target3_match_not[]='/188\.234\.242\.217/'
target3_match_not[]='/^91\.191\.236\.34/'
```

<br>

5. По окончании этапа калибровки - записать текущую метку времени:
```bash
# tee одновременно (для удобства) выводит дату в терминал и записываем в указанный файл
date +"%Y-%m-%dT%H:%M:%S" | tee /root/last-waf-ii-check.log
```
